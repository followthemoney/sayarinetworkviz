<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relationship Network Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .upload-section {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #4CAF50;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            margin-right: 15px;
        }
        
        .file-input-wrapper:hover {
            background-color: #45a049;
        }
        
        .file-input {
            position: absolute;
            left: -9999px;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .search-box {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            min-width: 200px;
        }
        
        .search-box:focus {
            border-color: #4CAF50;
            outline: none;
        }
        
        .button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .button:hover {
            background-color: #45a049;
        }
        
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .info-panel {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #2196F3;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .stat-item {
            background: #f5f5f5;
            padding: 10px 15px;
            border-radius: 4px;
            min-width: 120px;
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        
        .legend {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .legend h3 {
            margin-top: 0;
            color: #333;
        }
        
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #ccc;
        }
        
        #sigma-container {
            width: 100%;
            height: 700px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
        }
        
        .node-info {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 250px;
            word-wrap: break-word;
        }
        
        .edge-info {
            position: absolute;
            background: rgba(66, 165, 245, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        .file-list {
            margin-top: 10px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .file-item {
            background: #e8f5e8;
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Relationship Network Visualization</h1>
        
        <div class="upload-section">
            <h3>Upload CSV Files</h3>
            <p>Upload your relationship CSV files (multiple files supported). Expected format: source, source_type, source_label, relationship, target, target_type, target_label, properties, record, former</p>
            
            <label for="csvFiles" class="file-input-wrapper">
                Choose CSV Files
                <input type="file" id="csvFiles" class="file-input" multiple accept=".csv" />
            </label>
            
            <button id="process-btn" class="button" disabled>Process Files</button>
            <button id="clear-btn" class="button">Clear All</button>
            
            <div id="file-list" class="file-list"></div>
        </div>
        
        <div id="stats" class="stats" style="display: none;">
            <div class="stat-item">
                <div id="node-count" class="stat-number">0</div>
                <div class="stat-label">Nodes</div>
            </div>
            <div class="stat-item">
                <div id="edge-count" class="stat-number">0</div>
                <div class="stat-label">Edges</div>
            </div>
            <div class="stat-item">
                <div id="file-count" class="stat-number">0</div>
                <div class="stat-label">Files Loaded</div>
            </div>
        </div>
        
        <div id="legend" class="legend" style="display: none;">
            <h3>Node Types</h3>
            <div id="legend-items" class="legend-items"></div>
        </div>
        
        <div id="info-panel" class="info-panel" style="display: none;">
            <strong>Instructions:</strong> 
            Click on any node to highlight its connections. Use the search box to find specific nodes. 
            Drag nodes to rearrange the layout, and use mouse wheel to zoom. Hover over edges to see relationship details.
        </div>
        
        <div id="controls" class="controls" style="display: none;">
            <input type="text" id="search" class="search-box" placeholder="Search nodes...">
            <button id="reset-btn" class="button">Reset View</button>
            <button id="layout-btn" class="button">Apply Layout</button>
            <button id="center-btn" class="button">Center View</button>
        </div>
        
        <div id="sigma-container" style="display: none;"></div>
        <div id="node-info" class="node-info"></div>
        <div id="edge-info" class="edge-info"></div>
    </div>

    <script>
        // Global variables
        let graph = null;
        let sigmaInstance = null;
        let selectedFiles = [];
        let allData = [];
        let nodeTypeColors = {};
        let selectedNode = null;
        let isLayoutRunning = false;
        
        // Color palette for different node types
        const colorPalette = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#e91e63', '#795548',
            '#607d8b', '#ff5722', '#009688', '#4caf50', '#cddc39',
            '#ffc107', '#673ab7', '#2196f3', '#00bcd4', '#8bc34a'
        ];
        
        // File handling
        document.getElementById('csvFiles').addEventListener('change', function(event) {
            selectedFiles = Array.from(event.target.files);
            updateFileList();
            document.getElementById('process-btn').disabled = selectedFiles.length === 0;
        });
        
        document.getElementById('process-btn').addEventListener('click', processFiles);
        document.getElementById('clear-btn').addEventListener('click', clearAll);
        
        function updateFileList() {
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';
            
            selectedFiles.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                fileList.appendChild(fileItem);
            });
            
            document.getElementById('file-count').textContent = selectedFiles.length;
        }
        
        function processFiles() {
            allData = [];
            let filesProcessed = 0;
            
            document.getElementById('process-btn').disabled = true;
            document.getElementById('process-btn').textContent = 'Processing...';
            
            selectedFiles.forEach(file => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        console.log(`Processed ${file.name}:`, results.data.length, 'rows');
                        allData = allData.concat(results.data);
                        filesProcessed++;
                        
                        if (filesProcessed === selectedFiles.length) {
                            createVisualization();
                        }
                    },
                    error: function(error) {
                        console.error('Error parsing', file.name, ':', error);
                        alert(`Error processing ${file.name}: ${error.message}`);
                    }
                });
            });
        }
        
        function createVisualization() {
            console.log('Total data rows:', allData.length);
            
            // Create new graph
            graph = new graphology.Graph({ type: 'undirected' });
            
            // Process data to create nodes and edges
            const nodeSet = new Set();
            const edgeMap = new Map();
            const nodeData = new Map();
            const typeSet = new Set();
            
            // First pass: collect all unique nodes and types
            allData.forEach(row => {
                if (row.source && row.target) {
                    nodeSet.add(row.source);
                    nodeSet.add(row.target);
                    typeSet.add(row.source_type);
                    typeSet.add(row.target_type);
                    
                    // Store node data
                    nodeData.set(row.source, {
                        label: row.source_label || row.source,
                        type: row.source_type
                    });
                    nodeData.set(row.target, {
                        label: row.target_label || row.target,
                        type: row.target_type
                    });
                }
            });
            
            // Assign colors to node types
            const types = Array.from(typeSet).filter(type => type);
            types.forEach((type, index) => {
                nodeTypeColors[type] = colorPalette[index % colorPalette.length];
            });
            
            // Add nodes to graph
            nodeSet.forEach(nodeId => {
                const data = nodeData.get(nodeId);
                if (data) {
                    graph.addNode(nodeId, {
                        label: data.label,
                        type: data.type,
                        color: nodeTypeColors[data.type] || '#999',
                        size: 8, // Will be updated based on degree
                        x: Math.random() * 10 - 5,
                        y: Math.random() * 10 - 5
                    });
                }
            });
            
            // Second pass: create edges and count relationships
            allData.forEach(row => {
                if (row.source && row.target && graph.hasNode(row.source) && graph.hasNode(row.target)) {
                    const edgeKey = [row.source, row.target].sort().join('||');
                    
                    if (edgeMap.has(edgeKey)) {
                        const edgeData = edgeMap.get(edgeKey);
                        edgeData.count++;
                        edgeData.relationships.add(row.relationship || 'connected');
                    } else {
                        edgeMap.set(edgeKey, {
                            source: row.source,
                            target: row.target,
                            count: 1,
                            relationships: new Set([row.relationship || 'connected'])
                        });
                    }
                }
            });
            
            // Add edges to graph with size based on count
            edgeMap.forEach((edgeData, edgeKey) => {
                try {
                    graph.addEdge(edgeData.source, edgeData.target, {
                        size: Math.min(Math.max(edgeData.count * 0.5, 1), 8),
                        count: edgeData.count,
                        relationships: Array.from(edgeData.relationships),
                        color: '#666',
                        label: Array.from(edgeData.relationships).join(', ')
                    });
                } catch (error) {
                    console.log('Edge already exists:', edgeData.source, '->', edgeData.target);
                }
            });
            
            // Update node sizes based on degree
            graph.forEachNode((node, attributes) => {
                const degree = graph.degree(node);
                graph.setNodeAttribute(node, 'size', Math.min(Math.max(degree * 2 + 5, 8), 25));
            });
            
            // Update UI
            updateStats();
            updateLegend();
            showVisualization();
            
            document.getElementById('process-btn').textContent = 'Process Files';
            document.getElementById('process-btn').disabled = false;
        }
        
        function updateStats() {
            document.getElementById('node-count').textContent = graph.order;
            document.getElementById('edge-count').textContent = graph.size;
            document.getElementById('stats').style.display = 'flex';
        }
        
        function updateLegend() {
            const legendItems = document.getElementById('legend-items');
            legendItems.innerHTML = '';
            
            Object.entries(nodeTypeColors).forEach(([type, color]) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'legend-color';
                colorDiv.style.backgroundColor = color;
                
                const label = document.createElement('span');
                label.textContent = type || 'Unknown';
                
                item.appendChild(colorDiv);
                item.appendChild(label);
                legendItems.appendChild(item);
            });
            
            document.getElementById('legend').style.display = 'block';
        }
        
        function showVisualization() {
            // Show UI elements
            document.getElementById('info-panel').style.display = 'block';
            document.getElementById('controls').style.display = 'flex';
            document.getElementById('sigma-container').style.display = 'block';
            
            // Create Sigma instance
            if (sigmaInstance) {
                sigmaInstance.kill();
            }
            
            sigmaInstance = new Sigma(graph, document.getElementById("sigma-container"), {
                renderLabels: true,
                defaultNodeColor: "#999",
                defaultEdgeColor: "#666",
                labelFont: "Arial",
                labelSize: 12,
                labelWeight: "bold",
                labelThreshold: 8
            });
            
            setupInteractions();
            
            // Apply initial layout
            setTimeout(() => {
                applyLayout();
            }, 500);
        }
        
        function setupInteractions() {
            // Node click handler
            sigmaInstance.on("clickNode", (event) => {
                const nodeId = event.node;
                
                if (selectedNode === nodeId) {
                    resetHighlight();
                    return;
                }
                
                selectedNode = nodeId;
                
                // Get neighbors
                const neighbors = new Set(graph.neighbors(nodeId));
                neighbors.add(nodeId);
                
                // Highlight connected nodes and edges
                graph.forEachNode((node, attributes) => {
                    graph.setNodeAttribute(node, "color", 
                        neighbors.has(node) ? attributes.color : "#ddd");
                    graph.setNodeAttribute(node, "size", 
                        neighbors.has(node) ? attributes.size : attributes.size * 0.5);
                });
                
                graph.forEachEdge((edge, attributes, source, target) => {
                    const isConnected = neighbors.has(source) && neighbors.has(target);
                    graph.setEdgeAttribute(edge, "color", isConnected ? "#333" : "#eee");
                });
                
                sigmaInstance.refresh();
            });
            
            // Click on empty space to reset
            sigmaInstance.on("clickStage", () => {
                resetHighlight();
            });
            
            // Node hover
            const nodeInfo = document.getElementById("node-info");
            
            sigmaInstance.on("enterNode", (event) => {
                const node = graph.getNodeAttributes(event.node);
                const degree = graph.degree(event.node);
                nodeInfo.innerHTML = `
                    <strong>${node.label}</strong><br>
                    Type: ${node.type}<br>
                    Connections: ${degree}
                `;
                nodeInfo.style.display = "block";
            });
            
            sigmaInstance.on("leaveNode", () => {
                nodeInfo.style.display = "none";
            });
            
            // Edge hover
            const edgeInfo = document.getElementById("edge-info");
            
            sigmaInstance.on("enterEdge", (event) => {
                const edge = graph.getEdgeAttributes(event.edge);
                const endpoints = graph.extremities(event.edge);
                const sourceLabel = graph.getNodeAttribute(endpoints[0], 'label');
                const targetLabel = graph.getNodeAttribute(endpoints[1], 'label');
                
                edgeInfo.innerHTML = `
                    <strong>${sourceLabel} ↔ ${targetLabel}</strong><br>
                    ${edge.relationships.join(', ')}<br>
                    Strength: ${edge.count}
                `;
                edgeInfo.style.display = "block";
            });
            
            sigmaInstance.on("leaveEdge", () => {
                edgeInfo.style.display = "none";
            });
            
            // Update tooltip positions
            document.addEventListener("mousemove", (event) => {
                nodeInfo.style.left = (event.clientX + 10) + "px";
                nodeInfo.style.top = (event.clientY + 10) + "px";
                edgeInfo.style.left = (event.clientX + 10) + "px";
                edgeInfo.style.top = (event.clientY - 40) + "px";
            });
            
            // Search functionality
            const searchInput = document.getElementById("search");
            searchInput.addEventListener("input", (event) => {
                const searchTerm = event.target.value.toLowerCase();
                
                if (searchTerm === "") {
                    resetHighlight();
                    return;
                }
                
                const matchingNodes = new Set();
                graph.forEachNode((node, attributes) => {
                    if (attributes.label.toLowerCase().includes(searchTerm) ||
                        attributes.type.toLowerCase().includes(searchTerm)) {
                        matchingNodes.add(node);
                    }
                });
                
                // Highlight matching nodes
                graph.forEachNode((node, attributes) => {
                    const isMatch = matchingNodes.has(node);
                    graph.setNodeAttribute(node, "color", 
                        isMatch ? attributes.color : "#ddd");
                    graph.setNodeAttribute(node, "size", 
                        isMatch ? attributes.size * 1.2 : attributes.size * 0.5);
                });
                
                sigmaInstance.refresh();
            });
            
            // Control buttons
            document.getElementById("reset-btn").addEventListener("click", () => {
                resetHighlight();
                document.getElementById("search").value = "";
            });
            
            document.getElementById("layout-btn").addEventListener("click", applyLayout);
            
            document.getElementById("center-btn").addEventListener("click", () => {
                sigmaInstance.getCamera().setState({ x: 0, y: 0, ratio: 1 });
            });
        }
        
        function resetHighlight() {
            selectedNode = null;
            graph.forEachNode((node, attributes) => {
                graph.setNodeAttribute(node, "color", nodeTypeColors[attributes.type] || '#999');
                graph.setNodeAttribute(node, "size", attributes.size);
            });
            
            graph.forEachEdge((edge) => {
                graph.setEdgeAttribute(edge, "color", "#666");
            });
            
            sigmaInstance.refresh();
        }
        
        function applyLayout() {
            if (isLayoutRunning || !graph) return;
            
            isLayoutRunning = true;
            const button = document.getElementById("layout-btn");
            button.textContent = "Applying Layout...";
            button.disabled = true;
            
            // Simple force-directed layout
            for (let i = 0; i < 150; i++) {
                setTimeout(() => {
                    applyForceDirectedStep();
                    sigmaInstance.refresh();
                    
                    if (i === 149) {
                        isLayoutRunning = false;
                        button.textContent = "Apply Layout";
                        button.disabled = false;
                    }
                }, i * 15);
            }
        }
        
        function applyForceDirectedStep() {
            const nodes = graph.nodes();
            const positions = {};
            
            nodes.forEach(nodeA => {
                let fx = 0, fy = 0;
                const posA = { 
                    x: graph.getNodeAttribute(nodeA, "x"), 
                    y: graph.getNodeAttribute(nodeA, "y") 
                };
                
                // Repulsive forces
                nodes.forEach(nodeB => {
                    if (nodeA === nodeB) return;
                    
                    const posB = { 
                        x: graph.getNodeAttribute(nodeB, "x"), 
                        y: graph.getNodeAttribute(nodeB, "y") 
                    };
                    const dx = posA.x - posB.x;
                    const dy = posA.y - posB.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
                    
                    const force = 0.5 / distance;
                    fx += (dx / distance) * force;
                    fy += (dy / distance) * force;
                });
                
                // Attractive forces for connected nodes
                graph.forEachNeighbor(nodeA, neighbor => {
                    const posB = { 
                        x: graph.getNodeAttribute(neighbor, "x"), 
                        y: graph.getNodeAttribute(neighbor, "y") 
                    };
                    const dx = posB.x - posA.x;
                    const dy = posB.y - posA.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
                    
                    const force = distance * 0.02;
                    fx += (dx / distance) * force;
                    fy += (dy / distance) * force;
                });
                
                positions[nodeA] = {
                    x: posA.x + fx * 0.1,
                    y: posA.y + fy * 0.1
                };
            });
            
            // Apply new positions
            Object.keys(positions).forEach(node => {
                graph.setNodeAttribute(node, "x", positions[node].x);
                graph.setNodeAttribute(node, "y", positions[node].y);
            });
        }
        
        function clearAll() {
            selectedFiles = [];
            allData = [];
            nodeTypeColors = {};
            
            if (sigmaInstance) {
                sigmaInstance.kill();
                sigmaInstance = null;
            }
            
            // Reset UI
            document.getElementById('csvFiles').value = '';
            document.getElementById('file-list').innerHTML = '';
            document.getElementById('process-btn').disabled = true;
            document.getElementById('search').value = '';
            
            // Hide visualization elements
            document.getElementById('stats').style.display = 'none';
            document.getElementById('legend').style.display = 'none';
            document.getElementById('info-panel').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('sigma-container').style.display = 'none';
            
            updateFileList();
        }
    </script>
</body>
</html>